# Fragile Policy Drop Statements - Technical Analysis

## Issue Summary

**File:** `fix_repo_archives_policies.sql`  
**Lines:** 13-21  
**Severity:** Medium  
**Type:** Maintainability / Reliability

## Problem Description

The script attempts to drop storage policies using hardcoded, Supabase-generated policy names that include hash suffixes:

```sql
DROP POLICY IF EXISTS "Service role full access to repo_archives 1u5llpa_0" ON storage.objects;
DROP POLICY IF EXISTS "Service role full access to repo_archives 1u5llpa_1" ON storage.objects;
DROP POLICY IF EXISTS "Service role full access to repo_archives 1u5llpa_2" ON storage.objects;
DROP POLICY IF EXISTS "Service role full access to repo_archives 1u5llpa_3" ON storage.objects;
DROP POLICY IF EXISTS "Users can manage own repo archives 1u5llpa_0" ON storage.objects;
DROP POLICY IF EXISTS "Users can manage own repo archives 1u5llpa_1" ON storage.objects;
DROP POLICY IF EXISTS "Users can manage own repo archives 1u5llpa_2" ON storage.objects;
DROP POLICY IF EXISTS "Users can manage own repo archives 1u5llpa_3" ON storage.objects;
```

## Root Cause Analysis

### Why This Pattern Exists

1. **Supabase UI Behavior**: When creating policies through the Supabase Dashboard UI, it automatically appends hash suffixes to policy names to ensure uniqueness
2. **Copy-Paste Development**: The developer likely copied the exact policy names from `pg_policies` at a specific point in time
3. **Lack of Awareness**: The developer may not have known that these suffixes are auto-generated and can change

### Why This Is Fragile

1. **Hash Suffix Variability**:
   - Format: `{base_name} {hash}_{index}`
   - Example: `1u5llpa_0`, `1u5llpa_1`
   - These hashes are generated by Supabase and can change if:
     - Policies are recreated via the UI
     - The database is migrated or restored
     - Supabase changes its internal naming algorithm

2. **Silent Failures**:
   - `DROP POLICY IF EXISTS` won't error if the policy doesn't exist
   - If the hash changes, the DROP statement silently does nothing
   - Old, broken policies remain in the database
   - New policies are created alongside old ones, causing conflicts

3. **Maintenance Burden**:
   - Every time policies are recreated, this script needs manual updates
   - Requires knowing the exact current policy names
   - Error-prone and time-consuming

## Technical Solution

### Approach: Dynamic Policy Discovery and Removal

Replace hardcoded names with a PL/pgSQL block that:
1. Queries `pg_policies` to find all matching policies
2. Dynamically drops each policy found
3. Provides feedback on what was dropped

### Implementation

```sql
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    -- Find all policies on storage.objects that relate to repo_archives
    FOR policy_record IN
        SELECT policyname
        FROM pg_policies
        WHERE schemaname = 'storage'
          AND tablename = 'objects'
          AND policyname LIKE '%repo_archives%'
    LOOP
        -- Drop each policy dynamically
        EXECUTE format('DROP POLICY IF EXISTS %I ON storage.objects', policy_record.policyname);
        RAISE NOTICE 'Dropped policy: %', policy_record.policyname;
    END LOOP;
END $$;
```

### Why This Works

1. **Dynamic Discovery**: Queries `pg_policies` system catalog to find actual policy names
2. **Pattern Matching**: Uses `LIKE '%repo_archives%'` to match any policy related to repo_archives
3. **Safe Execution**: Uses `format()` with `%I` for proper identifier quoting (prevents SQL injection)
4. **Visibility**: `RAISE NOTICE` provides feedback on what's being dropped
5. **Future-Proof**: Works regardless of hash suffixes or naming changes

## PostgreSQL System Catalog Reference

### `pg_policies` View

The `pg_policies` view provides information about row-level security policies:

```sql
SELECT 
    schemaname,      -- Schema containing the table
    tablename,       -- Table the policy applies to
    policyname,      -- Name of the policy
    permissive,      -- Whether policy is permissive or restrictive
    roles,           -- Roles the policy applies to
    cmd,             -- Command type (SELECT, INSERT, UPDATE, DELETE, ALL)
    qual,            -- USING expression
    with_check       -- WITH CHECK expression
FROM pg_policies
WHERE schemaname = 'storage' AND tablename = 'objects';
```

### Key Fields Used

- **`schemaname`**: Filter to 'storage' for storage policies
- **`tablename`**: Filter to 'objects' (storage bucket policies apply here)
- **`policyname`**: The actual policy name (including any Supabase-generated suffixes)

## Security Considerations

### SQL Injection Prevention

Using `format()` with `%I` is critical:

```sql
-- ‚úÖ SAFE - %I properly quotes identifiers
EXECUTE format('DROP POLICY IF EXISTS %I ON storage.objects', policy_record.policyname);

-- ‚ùå UNSAFE - Vulnerable to SQL injection
EXECUTE 'DROP POLICY IF EXISTS "' || policy_record.policyname || '" ON storage.objects';
```

The `%I` format specifier:
- Properly quotes identifiers
- Escapes special characters
- Prevents SQL injection attacks
- Handles edge cases (spaces, quotes, etc.)

### Pattern Matching Safety

Using `LIKE '%repo_archives%'`:
- ‚úÖ Safe for this use case (we control the pattern)
- ‚úÖ Specific enough to avoid unintended matches
- ‚ö†Ô∏è Could match unintended policies if naming is inconsistent
- üí° Consider more specific patterns if needed: `LIKE 'Service role full access to repo_archives%' OR LIKE 'Users can manage own repo archives%'`

## Comparison with Migration Files

### Good Examples from Existing Migrations

The codebase already has excellent examples of this pattern:

#### Example 1: `20251213083907_fix_repos_rls_performance.sql`

```sql
DO $$
DECLARE
    policy_record RECORD;
BEGIN
    FOR policy_record IN
        SELECT policyname, cmd, qual
        FROM pg_policies
        WHERE schemaname = 'public' AND tablename = 'repos'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON repos', policy_record.policyname);
        -- Additional logic to recreate with fixes
        RAISE NOTICE 'Fixed policy: %', policy_record.policyname;
    END LOOP;
END $$;
```

**Why This Is Good:**
- Queries all policies on the target table
- Drops dynamically without hardcoded names
- Recreates with improvements
- Provides feedback

#### Example 2: `20251212000002_deprecate_reasoning_tables.sql`

```sql
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN 
        SELECT policyname, tablename 
        FROM pg_policies 
        WHERE tablename LIKE 'reasoning_%'
    LOOP
        EXECUTE format('DROP POLICY IF EXISTS %I ON %I', r.policyname, r.tablename);
    END LOOP;
END $$;
```

**Why This Is Good:**
- Uses pattern matching for multiple tables
- Handles both policy name and table name dynamically
- Clean and maintainable

## Performance Considerations

### Query Performance

The `pg_policies` view is:
- ‚úÖ Fast to query (backed by system catalogs)
- ‚úÖ Indexed appropriately by PostgreSQL
- ‚úÖ Minimal overhead for small numbers of policies

### Execution Performance

For typical use cases:
- Small number of policies (< 100)
- Fast execution (milliseconds)
- No performance concerns

For large-scale deployments:
- Consider batching if dropping thousands of policies
- Add progress logging for long-running operations
- Test in staging environment first

## Testing Recommendations

### Before Running the Script

1. **Verify Current Policies**:
   ```sql
   SELECT policyname
   FROM pg_policies
   WHERE schemaname = 'storage'
     AND tablename = 'objects'
     AND policyname LIKE '%repo_archives%';
   ```

2. **Backup Policy Definitions**:
   ```sql
   SELECT policyname, cmd, qual, with_check
   FROM pg_policies
   WHERE schemaname = 'storage'
     AND tablename = 'objects'
     AND policyname LIKE '%repo_archives%';
   ```

### After Running the Script

1. **Verify Policies Were Dropped**:
   ```sql
   -- Should return 0 rows (or only the new policies)
   SELECT policyname
   FROM pg_policies
   WHERE schemaname = 'storage'
     AND tablename = 'objects'
     AND policyname LIKE '%repo_archives%';
   ```

2. **Verify New Policies Exist**:
   ```sql
   -- Should show the 2 new policies
   SELECT policyname, cmd
   FROM pg_policies
   WHERE schemaname = 'storage'
     AND tablename = 'objects'
     AND policyname IN (
       'Service role full access to repo_archives',
       'Users can manage own repo archives'
     );
   ```

## Lessons Learned

### For Developers

1. **Never Hardcode Auto-Generated Names**: If a name includes a hash or random suffix, it's likely auto-generated
2. **Query System Catalogs**: Use `pg_policies`, `pg_tables`, etc. to discover current state
3. **Use Dynamic SQL**: PL/pgSQL blocks with `EXECUTE format()` are your friend
4. **Provide Feedback**: `RAISE NOTICE` helps with debugging and verification
5. **Follow Existing Patterns**: Check migration files for established patterns

### For Code Review

1. **Flag Hardcoded Hashes**: Any policy name with a pattern like `_[a-z0-9]{7}_[0-9]` should be reviewed
2. **Suggest Dynamic Alternatives**: Point to existing migration examples
3. **Verify Testing**: Ensure the developer has tested in a staging environment
4. **Check for Silent Failures**: Ensure `DROP POLICY IF EXISTS` won't hide problems

## Future Improvements

### Potential Enhancements

1. **More Specific Pattern Matching**:
   ```sql
   WHERE policyname ~ '^(Service role full access to repo_archives|Users can manage own repo archives)'
   ```

2. **Dry-Run Mode**:
   ```sql
   -- Add a variable to control whether to actually drop
   DECLARE
       dry_run BOOLEAN := TRUE;
   BEGIN
       IF dry_run THEN
           RAISE NOTICE 'Would drop policy: %', policy_record.policyname;
       ELSE
           EXECUTE format('DROP POLICY IF EXISTS %I ON storage.objects', policy_record.policyname);
       END IF;
   END;
   ```

3. **Policy Backup**:
   ```sql
   -- Create a backup table before dropping
   CREATE TABLE IF NOT EXISTS policy_backup AS
   SELECT * FROM pg_policies
   WHERE schemaname = 'storage' AND tablename = 'objects'
     AND policyname LIKE '%repo_archives%';
   ```

## References

- [PostgreSQL System Catalogs](https://www.postgresql.org/docs/current/catalogs.html)
- [pg_policies View](https://www.postgresql.org/docs/current/view-pg-policies.html)
- [PL/pgSQL Dynamic SQL](https://www.postgresql.org/docs/current/plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN)
- [format() Function](https://www.postgresql.org/docs/current/functions-string.html#FUNCTIONS-STRING-FORMAT)
- [Supabase Storage Policies](https://supabase.com/docs/guides/storage/security/access-control)

## Conclusion

The fix transforms a fragile, maintenance-heavy approach into a robust, self-maintaining solution that:
- ‚úÖ Works regardless of Supabase naming changes
- ‚úÖ Provides visibility into what's being dropped
- ‚úÖ Follows established patterns in the codebase
- ‚úÖ Prevents silent failures
- ‚úÖ Requires no manual updates when policies are recreated

This pattern should be used as the standard approach for all policy management scripts going forward.
